C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\user\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\hardwa
                    -re\DELAY;..\hardware\ADC;..\hardware\Flash;..\hardware\Uart;..\hardware\Key;..\hardware\Pwm;..\hardware\WDT;..\hardware\
                    -Timer;..\hardware\LCDdisplay;..\hardware\PID) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\mai
                    -n.obj)

line level    source

   1          /**
   2          * ************************************************************************************
   3          * @Examle Version   K8104
   4          * @Demo Version   V1.00.00
   5          * @Date       2020.6??23
   6          * ************************************************************************************
   7          *
   8          **/
   9          
  10          #define ALLOCATE_EXTERN
  11          #include "HC89F3541.H"
  12          #include "delay.h"
  13          #include "adc.h"
  14          #include "flash.h"
  15          #include "key.h"
  16          #include "uart.h"
  17          #include "pwm.h"
  18          #include "wdt.h"
  19          #include "timer.h"
  20          #include "lcddisplay.h"
  21          #include "PID.h"
  22          #include "math.h"
  23          #include "stdio.h"
  24          #include "string.h"
  25          
  26          #define SKU 8006
  27          #define SOFT_VER "1.00.00"
  28          
  29          const u16 NTC_ADC_Table[30] =
  30          {
  31            //160, 148, 136, 124, 110, 102, 94, 86, 78,  70,  // 61℃ ~70℃
  32            65,  60,  55,  50,   45,  42, 39, 36, 33,  30,  // 71℃ ~80℃
  33            28,  26,  24,  22,   19,  18, 17, 16, 15,  13,  // 81℃ ~90℃
  34            12,  11,  10,   9,    8,   7,  6,  5,  4,   3,   // 91℃ ~100℃
  35          };
  36          u16 ADC_val[20] = {0};
  37          u16 ADC_val_PTC[20] = {0};
  38          u16 ADC_val_AC[20] = {0};
  39          u16 ADC_val_insert[20] = {0};
  40          
  41          u16 adc_cnt = 0;
  42          u8  first_heat_std = 0;
  43          u8  error_std = 0;
  44          u8  adc_test_std = 1;
  45          u8  Insert_std = 0;
  46          
  47          void Clock ( void );
  48          void Set_Temp ( u16 temp );
  49          void Controll_Heat ( u16 temp_set,u16 temp_now );
  50          u8 look_up_table ( const u16* a,u8 ArrayLong,u16 Data );
  51          //u8 calcuTem(u16 RW,const u16 * tempRes_buf);
  52          void Sort ( u16* arr, int n );
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 2   

  53          
  54          
  55          
  56          
  57          static void key_handle ( void )
  58          {
  59   1        u8 key_val = 0;
  60   1      
  61   1        if ( error_std == 0 )
  62   1      
  63   1        {
  64   2          key_val = key_scan();
  65   2        }
  66   1        else
  67   1        {
  68   2          key_val = 0;
  69   2        }
  70   1        if ( key_val == KEY_1_PRES )
  71   1        {
  72   2          KEY_printf ( " key_scan\r\n" );
  73   2          if ( get_device_state() == ON )
  74   2          {
  75   3            set_device_state ( OFF );
  76   3      
  77   3            set_pwm ( 0 );
  78   3          }
  79   2          else
  80   2          {
  81   3            set_device_state ( ON );
  82   3            set_time_sec();
  83   3      
  84   3            first_heat_std = 1;
  85   3      
  86   3          }
  87   2        }
  88   1        else if ( get_device_state() == ON )
  89   1        {
  90   2      
  91   2      
  92   2      
  93   2          if ( key_val == KEY_2_PRES ) //??
  94   2          {
  95   3      
  96   3            KEY_printf ( " KEY_2_PRES\r\n" );
  97   3            if ( flash_info.gap < GAP_H )
  98   3            {
  99   4              flash_info.gap++;
 100   4      
 101   4            }
 102   3            else
 103   3            {
 104   4              flash_info.gap = GAP_1;
 105   4            }
 106   3      
 107   3      
 108   3            first_heat_std = 1;
 109   3      
 110   3            lcd_display_gap ( flash_info.gap );
 111   3            //set_time_sec();
 112   3            flah_save_data();
 113   3          }
 114   2          else if ( key_val == KEY_3_PRES ) //??
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 3   

 115   2          {
 116   3      
 117   3            if ( flash_info.timer < 0x05 )
 118   3            {
 119   4              flash_info.timer++;
 120   4            }
 121   3            else
 122   3            {
 123   4              flash_info.timer = TIMER_ON;
 124   4            }
 125   3      
 126   3            KEY_printf ( "timer:%d \r\n", ( u16 ) flash_info.timer );
 127   3            lcd_display_time ( flash_info.timer );
 128   3            set_time_sec();
 129   3            flah_save_data();
 130   3          }
 131   2        }
 132   1      }
 133          
 134          u16 temp_calc_PTC ( u16* adc_pdata )
 135          {
 136   1        float temp1 = 0;
 137   1        float temp2 = 0;
 138   1        u16 i = 0;
 139   1        u16  bais_temp = 25;
 140   1      
 141   1        Sort ( adc_pdata, 20 );
 142   1      
 143   1      //  for ( i=0; i<20; i++ )
 144   1      //  {
 145   1      //    gm_printf ( " %d  ",adc_pdata[i] );
 146   1      //  }
 147   1      //  if ( adc_pdata[19] < 10 )
 148   1      //  {
 149   1      //    return 0xff;
 150   1      //  }
 151   1      //  gm_printf ( "adc_max = %d  \r\n",adc_pdata[19] );
 152   1        temp1 = ( float ) adc_pdata[19]/4095;
 153   1      
 154   1      //  gm_printf ( "u1 = %f  \r\n",temp1 );
 155   1        temp1 = temp1*4.2;
 156   1      //  gm_printf ( "temp1 = %f  \r\n",temp1 );
 157   1        temp1 = temp1/1.414;
 158   1      //  gm_printf ( "AC_real = %f  \r\n",temp1 );
 159   1        temp2 = 120 - temp1;
 160   1      //  gm_printf ( "AC_PTC_real = %f  \r\n",temp2 );
 161   1      
 162   1        temp2 =  temp2/ temp1*0.43;
 163   1        gm_printf ( "PTC_R = %f  \r\n",temp2 );
 164   1        if ( temp2 < 122.93 )
 165   1        {
 166   2          return 0;
 167   2        }
 168   1      
 169   1        if ( temp2 >Temperature_Value )
 170   1        {
 171   2          temp1 = temp2 - Temperature_Value;
 172   2          i = ( u16 ) ( temp1 / 0.57 );
 173   2          bais_temp = bais_temp + i;
 174   2          if (bais_temp > 100)
 175   2            return 0xff;
 176   2        }
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 4   

 177   1        else  if ( temp2 < Temperature_Value )
 178   1        {
 179   2          temp1 = Temperature_Value - temp2;
 180   2          i = ( u16 ) ( temp1 / 0.57 );
 181   2          if ( i > 25 )
 182   2          {
 183   3            i = 25;
 184   3          }
 185   2      
 186   2          bais_temp = bais_temp - i;
 187   2        }
 188   1        gm_printf ( "PTC_temper = %d  \r\n", bais_temp );
 189   1      
 190   1        return bais_temp;
 191   1      }
 192          
 193          u16 temp_calc ( u16* adc_NTC_pdata )
 194          {
 195   1        float u1 = 0;
 196   1        float u3 = 0;
 197   1        int i = 0;
 198   1        u32 adc_max =0;
 199   1      
 200   1      //  if ( PTC_VAL < 50 )
 201   1      //  {
 202   1      //    return 0xff;
 203   1      //  }
 204   1      //  gm_printf ( " adc_NTC_pdata:\r\n" );
 205   1      //  for ( i=0; i<20; i++ )
 206   1      //  {
 207   1      //    gm_printf ( " %d  ",adc_NTC_pdata[i] );
 208   1      //  }
 209   1      //  gm_printf ( "\r\n" );
 210   1        Sort ( adc_NTC_pdata, 20 );
 211   1      //  gm_printf ( "sort:\r\n" );
 212   1      //  for ( i=0; i<20; i++ )
 213   1      //  {
 214   1      //    gm_printf ( " %d  ",adc_NTC_pdata[i] );
 215   1      //  }
 216   1      //  gm_printf ( "\r\n" );
 217   1      //  gm_printf ( "\r\n");
 218   1      
 219   1        //u1 = PTC_adc_val /1000;
 220   1      
 221   1      //   NTC_adc_val = sqrt ( NTC_adc_val/50 );
 222   1      //  gm_printf ( "u1 = %d  \r\n",adc_NTC_pdata[19] );
 223   1      
 224   1      
 225   1        u1 = ( float ) adc_NTC_pdata[19]/4095;
 226   1      //  gm_printf ( "u1 = %f  \r\n",u1 );
 227   1        u1 = u1*4;
 228   1      //  gm_printf ( "u1 = %f  \r\n",u1 );
 229   1        u1 = u1/1.414;
 230   1      //  gm_printf ( "u1 = %f  \r\n",u1 );
 231   1      
 232   1        u3 = 120.00 - u1;
 233   1      //  gm_printf ( "u3 = %f  \r\n",u3 );
 234   1      
 235   1        u3 = u3/u1*510;
 236   1        gm_printf ( "NTC_R = %f  \r\n",u3 );
 237   1        adc_max = u3/1000;
 238   1        // gm_printf ( "adc_max = %d  \r\n",(u16)adc_max );
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 5   

 239   1        i = look_up_table ( NTC_ADC_Table,30, ( u16 ) adc_max );
 240   1        gm_printf ( "NTC_temp = %d  \r\n",i );
 241   1        return ( i );
 242   1      }
 243          
 244          void  temp_calc_AC_Insert ( u16* pdata_ac,u16* pdata_insert )
 245          {
 246   1        float u1 = 0;
 247   1        float u3 = 0;
 248   1        int i = 0;
 249   1        u32 adc_max =0;
 250   1      
 251   1        Sort ( pdata_ac, 20 );
 252   1        
 253   1        gm_printf ( "AC:\r\n");
 254   1        for ( i=0; i<20; i++ )
 255   1        {
 256   2          gm_printf ( " %d  ",pdata_ac[i] );
 257   2        }
 258   1        gm_printf ( "\r\n" );
 259   1        gm_printf ( "pdata_ac_max = %d\r\n",pdata_ac[19]);
 260   1        gm_printf ( "\r\n");
 261   1        gm_printf ( "\r\n");
 262   1      
 263   1        gm_printf ( "Insert:\r\n");
 264   1        Sort ( pdata_insert, 20 );
 265   1        for ( i=0; i<20; i++ )
 266   1        {
 267   2          gm_printf ( " %d  ",pdata_insert[i] );
 268   2        }
 269   1        gm_printf ( "\r\n" );
 270   1        gm_printf ( "pdata_insert_max = %d\r\n",pdata_insert[19]);
 271   1        gm_printf ( "\r\n" );
 272   1        gm_printf ( "\r\n" );
 273   1        
 274   1      
 275   1      }
 276          
 277          
 278          
 279          
 280          
 281          /**
 282            * @brief  temperature_handle
 283          
 284            * @param  temp_set
 285            * @param  temp_now
 286            * @retval None
 287            */
 288          void temperature_handle ( void )
 289          {
 290   1        u16 temp = 0;
 291   1        static u16 adc_val1 = 0,adc_val3 = 0;
 292   1        static u16 adc_val_input = 0,adc_val_insert = 0;
 293   1        static u16 adc_test = 0;
 294   1        static u8 adc_times = 0;
 295   1        adc_cnt++;
 296   1        if ( adc_test_std == 1 )
 297   1        {
 298   2      
 299   2          if ( ++adc_test >= 50 )
 300   2          {
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 6   

 301   3      
 302   3      
 303   3      
 304   3            adc_test = 0;
 305   3            get_ADC_val ( &adc_val1, &adc_val3 );
 306   3            calc_InputAndInsert_val ( &adc_val_input, &adc_val_insert );
 307   3            ADC_val[adc_times] = adc_val3;
 308   3            ADC_val_PTC[adc_times] = adc_val1;
 309   3            ADC_val_AC[adc_times] = adc_val_input;
 310   3            ADC_val_insert[adc_times] = adc_val_insert;
 311   3            adc_times++;
 312   3            //    PTC_adc_val = PTC_adc_val + adc_val1;
 313   3      
 314   3            //  NTC_adc_val = NTC_adc_val + ( adc_val3*adc_val1 );
 315   3      
 316   3          }
 317   2          if ( adc_times > 20 )
 318   2          {
 319   3            adc_times = 0;
 320   3            adc_test_std = 2;
 321   3          }
 322   2        }
 323   1        if ( adc_cnt >= 50000 )
 324   1        {
 325   2          adc_cnt = 0;
 326   2      
 327   2          if ( adc_test_std == 2 )
 328   2          {
 329   3      //      gm_printf ( " adc_test_std = 2\r\n" );
 330   3      //      gm_printf ( "\r\n" );
 331   3            temp_calc ( ADC_val );
 332   3            temp = temp_calc_PTC ( ADC_val_PTC );
 333   3            temp_calc_AC_Insert ( ADC_val_AC,ADC_val_insert );
 334   3            //  KEY_printf ( "PTC = %d  NTC =%d\r\n",PTC_adc_val,NTC_adc_val );  //pjw set
 335   3      
 336   3            adc_test_std = 1;
 337   3            //  KEY_printf ( "temp val:%d \r\n",temp );
 338   3          }
 339   2          if ( 1 )  //adc_val1 >50
 340   2          {
 341   3            if ( 1 ) //get_device_state() == OFF
 342   3            {
 343   4              if ( first_heat_std == 1 )
 344   4              {
 345   5                first_heat_std = 0;
 346   5                if ( temp > 50 )
 347   5                {
 348   6                  Heat_start_std = 1;
 349   6                  Open_Heat_Value = corrected_value_GAP_4_temp  ;
 350   6                }
 351   5                else
 352   5                {
 353   6                  Heat_start_std = 1;
 354   6                  Open_Heat_Value = corrected_value_warm_temp ;
 355   6                }
 356   5              }
 357   4      
 358   4              lcd_display_time ( flash_info.timer );
 359   4              lcd_display_gap ( flash_info.gap );
 360   4              //  Set_Temp ( temp );
 361   4              set_pwm ( 10 );
 362   4            }
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 7   

 363   3            else
 364   3            {
 365   4              set_pwm ( 0 );
 366   4              lcd_clear_all();
 367   4            }
 368   3            error_std = 0;
 369   3          }
 370   2          else
 371   2          {
 372   3            set_pwm ( 0 );
 373   3      
 374   3            lcd_error (  );
 375   3            error_std = 1;
 376   3          }
 377   2      
 378   2      //    ADC_EN = 1;  //close ADC
 379   2        }
 380   1      
 381   1      
 382   1      }
 383          
 384          
 385          
 386          
 387          
 388          
 389          
 390          
 391          void main()
 392          {
 393   1        Clock();
 394   1        uart_init();
 395   1        adc_init();
 396   1        EA = 1;
 397   1        time0_init ();
 398   1        key_init();
 399   1        flash_init();
 400   1        pwm_init ( 200 );
 401   1        wdt_init ( 2 );
 402   1        LCD_Init();
 403   1        lcd_display_On();
 404   1        delay_ms ( 1200 );
 405   1        lcd_clear_all ();
 406   1        gm_printf ( "\r\n==================================\r\n" );
 407   1        gm_printf ( "sku:K%d \r\n", ( u16 ) SKU );
 408   1        gm_printf ( "soft version:%s \r\n",SOFT_VER );
 409   1        gm_printf ( "gap %d \r\n", ( u16 ) flash_info.gap );
 410   1        gm_printf ( "timer %d \r\n", ( u16 ) flash_info.timer );
 411   1        gm_printf ( "==================================\r\n" );
 412   1      
 413   1        while ( 1 )
 414   1        {
 415   2      
 416   2          temperature_handle();
 417   2          key_handle ();
 418   2          clear_wdt();
 419   2      
 420   2        }
 421   1      }
 422          
 423          
 424          
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 8   

 425          void Clock ( void )
 426          {
 427   1        /************************************??????????****************************************/
 428   1        CLKSWR = 0x51;            //Fosc=16MHz
 429   1        CLKDIV = 0x01;            //Fosc/1 = Fcpu=16MHz
 430   1      }
 431          
 432          
 433          /**
 434            * @brief  controll_PWM on/off heat
 435            * @param  temp_set
 436            * @param  temp_now
 437            * @retval None
 438            */
 439          
 440          void Controll_Heat ( u16 temp_set,u16 temp_now )
 441          {
 442   1      
 443   1        if ( temp_now >=  temp_set   )
 444   1        {
 445   2          //KEY_printf ( "close_heat \r\n");
 446   2          set_pwm ( 0 );
 447   2        }
 448   1        else if ( temp_now <= ( temp_set - Open_Heat_Value ) )
 449   1        {
 450   2          //KEY_printf ( "open_heat \r\n");
 451   2          set_pwm ( 10 );
 452   2        }
 453   1      }
 454          /**
 455            * @brief  set temperature from now_temper and GAP
 456            * @param  now_temper
 457            * @param  null
 458            * @retval None
 459            */
 460          
 461          void Set_Temp ( u16 temp )
 462          {
 463   1      
 464   1      
 465   1        switch ( flash_info.gap )
 466   1        {
 467   2          case GAP_WARM:
 468   2            Controll_Heat ( GAP_WARM_temp,temp );
 469   2            break;
 470   2          case GAP_1:
 471   2            Controll_Heat ( GAP_1_temp,temp );
 472   2            break;
 473   2          case GAP_2:
 474   2            Controll_Heat ( GAP_2_temp,temp );
 475   2            break;
 476   2          case GAP_3:
 477   2            Controll_Heat ( GAP_3_temp,temp );
 478   2            break;
 479   2          case GAP_H:
 480   2            Controll_Heat ( GAP_4_temp,temp );
 481   2            break;
 482   2          case GAP_5:
 483   2            Controll_Heat ( GAP_5_temp,temp );
 484   2            break;
 485   2          case GAP_6:
 486   2            Controll_Heat ( GAP_6_temp,temp );
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 9   

 487   2            break;
 488   2          case GAP_7:
 489   2            Controll_Heat ( GAP_7_temp,temp );
 490   2            break;
 491   2          case GAP_8:
 492   2            Controll_Heat ( GAP_8_temp,temp );
 493   2            break;
 494   2          case GAP_9:
 495   2            Controll_Heat ( GAP_9_temp,temp );
 496   2            break;
 497   2      
 498   2        }
 499   1      }
 500          
 501          /**
 502            * @brief  protect -> Over  2H exchange GAP1
 503            * @param  null
 504            * @param  null
 505            * @retval None
 506            */
 507          //void Protect ( void )
 508          //{
 509          //  if ( over_rang_time_std == 1 )
 510          //  {
 511          //    if ( flash_info.gap > GAP_1 )
 512          //    {
 513          //      flash_info.gap = GAP_1;
 514          //
 515          //      flah_save_data();
 516          //      over_rang_time_std = 0;
 517          //    }
 518          //  }
 519          //}
 520          
 521          u8 look_up_table ( const u16* a,u8 ArrayLong,u16 Data )
 522          {
 523   1        u16 begin,end,middle ;
 524   1        u8 i ;
 525   1        begin = 0 ;
 526   1        end = ArrayLong-1 ;
 527   1        i = 0  ;
 528   1        if ( Data >= a[begin] )
 529   1        {
 530   2      
 531   2          return begin ;
 532   2        }
 533   1        else if ( Data <= a[end] )
 534   1        {
 535   2          return 100 ;
 536   2        }
 537   1        while ( begin < end )
 538   1        {
 539   2          middle = ( begin+end ) /2 ;
 540   2          if ( Data == a[middle] )
 541   2          {
 542   3            break ;
 543   3          }
 544   2          if ( Data < a[middle] && Data > a[middle+1] )
 545   2          {
 546   3            break ;
 547   3          }
 548   2          if ( Data > a[middle] )
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 10  

 549   2          {
 550   3            end = middle ;
 551   3          }
 552   2          else
 553   2          {
 554   3            begin = middle ;
 555   3          }
 556   2          if ( i++ > ArrayLong )
 557   2          {
 558   3            break ;
 559   3          }
 560   2        }
 561   1        if ( begin > end )
 562   1        {
 563   2          return 0 ;
 564   2        }
 565   1        return middle+70 ;
 566   1      }
 567          
 568          //u8 calcuTem(u16 RW,const u16 * tempRes_buf)
 569          //{
 570          //  u8 tempValue= 108;
 571          //  u8 i = 0;
 572          //  if ((RW < 4000)&&(RW > 6))
 573          //  {
 574          //    for ( i = 0 ; i < 181 ; i++)
 575          //    {
 576          //      if (RW >= tempRes_buf[i])
 577          //      {
 578          //        tempValue = i+20;
 579          //        break;
 580          //      }
 581          //    }
 582          //  }
 583          //
 584          //  return tempValue;
 585          //}
 586          void Sort ( u16* arr, int n )
 587          {
 588   1        int m, i, j;
 589   1        for ( i = 0; i < n - 1; i++ )
 590   1          for ( j = 0; j < n - 1 - i; j++ )
 591   1            if ( arr[j] > arr[j + 1] )
 592   1            {
 593   2              m = arr[j];
 594   2              arr[j] = arr[j + 1];
 595   2              arr[j + 1] = m;
 596   2            }
 597   1      }
 598          
 599          
 600          
 601          
*** WARNING C294 IN LINE 365 OF ..\user\main.c: unreachable code
*** WARNING C294 IN LINE 372 OF ..\user\main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2911    ----
   CONSTANT SIZE    =    311    ----
   XDATA SIZE       =    237      82
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.56.0.0   MAIN                                                              08/20/2020 19:57:58 PAGE 11  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
